#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     irseeker,       sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S3,     ColorSensor,    sensorColorNxtFULL)
#pragma config(Sensor, S4,     HTSMUX,         sensorI2CCustom)
#pragma config(Motor,  motorA,           ,             tmotorNXT, openLoop, encoder)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop, encoder)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     LeftWheels,    tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     Spindle,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     RightWheels,   tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     Lift,          tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Servo,  srvo_S1_C3_1,    servo1,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_5,    Hooks,                tServoStandard)
#pragma config(Servo,  srvo_S1_C3_6,    Gate,                 tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//experimental version that tests using a gyro.

//#include "JoystickDriver.c"
#include "hitechnic-irseeker-v2.h"	//used for IR Seeker
#include "lego-touch.h"
#include "hitechnic-gyro.h"


// Robot and Field Definitions

// Measurements
#define DIAMETER 7.62
#define TRACK_DISTANCE 55
#define RAMP_DISTANCE 155

// Directions
#define FORWARD true
#define BACKWARD false
#define CLOCKWISE true
#define COUNTER_CLOCKWISE false

// Lift
#define LIFT_MAX 11400
#define LIFT_TOP 11350
#define LIFT_MIDDLE 7550
#define LIFT_LOWER 3600
#define LIFT_BASE 0
#define LIFT_HOLD_POSITION_POWER 5

// Gate
#define GATE_CLOSED 180
#define GATE_OPEN 10

// Goal Finger Positions
#define GOAL_HOOKS_OPEN 10
#define GOAL_HOOKS_CLOSED 250

//delay
#define DELAY_TIME 10000

//used to regulate motors
#define REGULATED true
#define UNREGULATED false

//file used in Choice.c
#define DATA_FILE_NAME "choices.txt"

#define RAMP_START 1
#define PARKING_ZONE 0

#define NEED_DELAY 1
#define NO_DELAY 0


//Functions
void readChoices();	//reads choices made in Choices.c
void rampFunction();	//goes down the ramp to collect goals
void kickstand();		//kicks kickstand
void initializeRobot();
void calcMove(float centimeters, float power, bool direction, bool isRegulated);
void dualMotorTurn(float robotDegrees, float power, bool direction, bool isRegulated); //use power >60 if regulated
void moveLift(int encoderCounts);

//for irSeeker
tHTIRS2 irSeeker;

//for gyro
tHTGYRO gyroSensor;




bool isDelay;
int CurrentPosition;
int TargetPosition;

//const tMUXSensor GoalBaseTouch1 = msensor_S4_1;
//const tMUXSensor GoalBaseTouch2 = msensor_S4_2;
const tMUXSensor LiftLimitTouch = msensor_S4_3;


enum StartingPositionEnum {ParkingZone, Ramp};
StartingPositionEnum StartingPosition;

enum LiftStateEnum {Running, Stopped};
LiftStateEnum LiftState;

task holdPosition();
task LiftSafetyUpperLimitWatch();
task LiftSafetyLowerLimitWatch();
//task LiftSafetyLimitTouchWatch();
task IntegrateGyroHeading();

//stores the heading calculated by gyro
float gyroHeading =0.0;



task main()
{
	initializeRobot();
	//startTask (holdPosition);
	startTask (LiftSafetyUpperLimitWatch);
	startTask (LiftSafetyLowerLimitWatch);
	//startTask (LiftSafetyLimitTouchWatch);

	//waitForStart();

	// Robot specific code


	if(isDelay)	// If there is a delay wait
	{
		wait1Msec(DELAY_TIME);
	}

	if(StartingPosition == Ramp)
	{
		rampFunction();
	}
	else if(StartingPosition == ParkingZone)
	{
		kickstand();
	}

	while(true)
	{
		//intentional

	}

}

// Tasks
task holdPosition()
{
	while(true) // Constantly checks
	{
		if(nMotorEncoder[Lift] > TargetPosition) // if higher than supposed to be, lower it
		{
			motor[Lift] = -1 * LIFT_HOLD_POSITION_POWER;
		}

		if(nMotorEncoder[Lift] < TargetPosition) // if lower than supposed to be, raise it
		{
			motor[Lift] = LIFT_HOLD_POSITION_POWER;
		}
	} // while(true)
} // task holdPosition()

task LiftSafetyUpperLimitWatch(){
	while(1){
		if(nMotorEncoder[Lift]>LIFT_MAX){
			//stop the lift
			motor[Lift]=0;
			//move the lift back down to the limit.
			while(nMotorEncoder[Lift]>LIFT_MAX){
				motor[Lift]=-10;
				LiftState=Running;
			}
			//now stop the motor again.
			motor[Lift]=0;
			LiftState=Stopped;
		}
	}
}

task LiftSafetyLowerLimitWatch(){
	while(1){
		if(nMotorEncoder[Lift]<LIFT_BASE){
			//stop the lift
			motor[Lift]=0;
			//rewind the cable to zero
			while(nMotorEncoder[Lift]<LIFT_BASE){
				motor[Lift]=10;
				LiftState=Running;
			}
			//stop the motor again
			motor[Lift]=0;
			LiftState=Stopped;
		}
	}
}

task LiftSafetyLimitTouchWatch(){
	while(1){
		if(TSreadState(LiftLimitTouch) != 0){
			playTone(1000,5);
			//stop the lift
			motor[Lift]=0;
			//move the lift back down to the limit.
			while(nMotorEncoder[Lift]>LIFT_MAX){
				motor[Lift]=-10;
				LiftState=Running;
			}
			//now stop the motor again.
			motor[Lift]=0;
			LiftState=Stopped;
		}
	}
}

// Functions

void initializeRobot()
{
	// Initializes servos
	servo[Gate] = GATE_CLOSED;
	servo[Hooks] = GOAL_HOOKS_OPEN;

	readChoices(); // Reads choices from a file that is written in from a program called Choices

	initSensor(&irSeeker, S2);
	wait1Msec(500);
	//wait for stability of sensor before setting the mode.
	irSeeker.mode = DSP_1200;

	wait1Msec(500);




	//Initialise and configure struct and port for gyro
	//adjusted:

 	initSensor(&gyroSensor, msensor_S4_4);
  // Start the calibration and display the offset
 	sensorCalibrate(&gyroSensor);



	nMotorEncoder[LeftWheels] = 0;
	nMotorEncoder[RightWheels] = 0;
	nMotorEncoder[Lift] = 0;
}

void rampFunction() //ramp, goals
{

	float CorrectedDistance=0.0;
	float CorrectedAngle=0.0;
	float Shift=0.0;

	//start the Gyro value integration in order to correct for the ramp direction errors
	gyroHeading=0.0;
	startTask(IntegrateGyroHeading);
	calcMove(RAMP_DISTANCE, 50, BACKWARD, REGULATED);		//goes down ramp
	wait1Msec(500); //wait for steadying of gyro.

	stopTask(IntegrateGyroHeading);
	//stop the Gyro Integration task.
	//Now use values.



	eraseDisplay();
	displayTextLine(2,"Dir Err: %4f", gyroHeading);
	wait1Msec(500);

	//now correct for this error.

	if(gyroHeading>0){

	//this branch is not debugged. We always get a negative turn (counter clockwise) coming off ramp

		playTone(5000,5);
		//calculated, Shift, Corrected Angles and Distance
		Shift=(sinDegrees(abs(gyroHeading))/(cosDegrees(abs(gyroHeading))))*RAMP_DISTANCE;

		CorrectedDistance=sqrt(pow(Shift,2)+pow(65,2));
		CorrectedAngle=90+abs(gyroHeading)-(atan(65/Shift)*(180/PI));

		eraseDisplay();
		displayTextLine(1,"Corr Angle:%4f", CorrectedAngle);
		displayTextLine(2,"Corr Dist: %4f", CorrectedDistance-5); //with adjustment to avoid hitting perimeter

		wait1Msec(5000);

		dualMotorTurn(CorrectedAngle,70,COUNTER_CLOCKWISE,REGULATED);

		calcMove(CorrectedDistance-5,30,BACKWARD, REGULATED);


		//final turn to align robot straight
		dualMotorTurn(90-(atan(65/Shift)*(180/PI)),70,CLOCKWISE, REGULATED);



	}



	if(gyroHeading<0){
	//negative error, turn clockwise,  (trigonometry), to get to where we need after correction.

	  //calculated, Shift, Corrected Angles and Distance
		Shift=(sinDegrees(abs(gyroHeading))/(cosDegrees(abs(gyroHeading))))*RAMP_DISTANCE;

		CorrectedDistance=sqrt(pow(Shift,2)+pow(65,2))-18; //adjustment of 18cm to avoid hitting edge
		CorrectedAngle=90+abs(gyroHeading)-(atan(65/Shift)*(180/PI));

		eraseDisplay();
		displayTextLine(1,"Shift Dist:%4f", Shift);
		displayTextLine(2,"Corr Angle:%4f", CorrectedAngle);
		displayTextLine(3,"Corr Dist: %4f", CorrectedDistance);

		wait1Msec(500);



		dualMotorTurn(CorrectedAngle,70,CLOCKWISE,REGULATED);

		calcMove(CorrectedDistance,30,BACKWARD, REGULATED);

		//final correction to make the robot face the goal head on.
		dualMotorTurn(90-(atan(65/Shift)*(180/PI)),70,COUNTER_CLOCKWISE, REGULATED);

	}

wait1Msec(500);

//push the robot slowly right next to goal
	calcMove(7,20,BACKWARD,REGULATED);
//too fast and it will bounce off the edge of robot.
	//try scoring goal.

	moveLift(LIFT_MIDDLE);
	servo[Gate]=GATE_OPEN;
	wait1Msec(2000);
	moveLift(LIFT_BASE);




	dualMotorTurn(5, 40, CLOCKWISE, REGULATED);
	servo[Hooks] = GOAL_HOOKS_CLOSED; // Grabs the goal
	wait1Msec(300);
	// Waits because the servo has time to move before the wheels start moving

	dualMotorTurn(30, 60, CLOCKWISE, REGULATED);

	calcMove(225, 90, FORWARD, REGULATED);
	dualMotorTurn(180, 60, COUNTER_CLOCKWISE, REGULATED);



}

void kickstand()	//kicks kickstand depending on directional value of irseeker
{
	readSensor(&irSeeker); // Reads the IR sensor values

	switch(irSeeker.acDirection)
	{

	case 3:	// for Position 2
		calcMove(110, 50, FORWARD, REGULATED);
		dualMotorTurn(30, 40, CLOCKWISE, REGULATED);
		calcMove(25, 50, FORWARD, REGULATED);
		dualMotorTurn(45, 70, CLOCKWISE, REGULATED);
		break;

	case 5:	// for Position 3
		if(irSeeker.enhStrength < 54)
		{
			calcMove(40, 50, FORWARD, REGULATED);
			dualMotorTurn(40, 40, COUNTER_CLOCKWISE, REGULATED);
			calcMove(105, 50, FORWARD, REGULATED);
			dualMotorTurn(130, 40, CLOCKWISE, REGULATED);
			calcMove(55, 60, FORWARD, REGULATED);
			dualMotorTurn(90, 40, CLOCKWISE, REGULATED);
		}
		if(irSeeker.enhStrength > 54)
		{
			calcMove(30, 50, FORWARD, REGULATED);
			dualMotorTurn(30, 40, CLOCKWISE, REGULATED);
			calcMove(60, 50, FORWARD, REGULATED);
			dualMotorTurn(32, 40, COUNTER_CLOCKWISE, REGULATED);
			calcMove(67, 50, FORWARD, REGULATED);
			dualMotorTurn(90, 40, CLOCKWISE, REGULATED);
		}
		break;
	}	//switch
}

// for moving forward and backword
void calcMove(float centimeters, float power, bool direction, bool isRegulated)
{
	float encoder_counts;

	if(isRegulated)	//turns on pid control (originally in pragma statements)
	{
		nMotorPIDSpeedCtrl[LeftWheels] = mtrSpeedReg;
		nMotorPIDSpeedCtrl[RightWheels] = mtrSpeedReg;
	}
	else
	{
		nMotorPIDSpeedCtrl[LeftWheels] = mtrNoReg;
		nMotorPIDSpeedCtrl[RightWheels] = mtrNoReg;
	}

	// Resets encoders
	nMotorEncoder[LeftWheels] = 0;
	nMotorEncoder[RightWheels] = 0;

	encoder_counts = (centimeters / (DIAMETER * PI)) * 1440; // converts centimeters to motor encoder counts

	if (!direction) //check for direction.
	{
		power = -1 * power;
		encoder_counts = -1 * encoder_counts;
	}

	//set the target encoder values before we set power to start motors.
	nMotorEncoderTarget[LeftWheels] = encoder_counts;
	nMotorEncoderTarget[RightWheels] = encoder_counts;

	motor[LeftWheels] = power;
	motor[RightWheels] = power;

	while((nMotorRunState[LeftWheels] != runStateIdle) && (nMotorRunState[RightWheels] != runStateIdle))
	{
		// Do nothing while we wait for motors to spin to correct distance.
	}

	//stop the motors
	motor[LeftWheels] = 0;
	motor[RightWheels] = 0;

	//set back to unregulated gmotors just so we dont have the wrong mode when exiting
	nMotorPIDSpeedCtrl[LeftWheels] = mtrNoReg;
	nMotorPIDSpeedCtrl[RightWheels] = mtrNoReg;
}

//for turning with two wheels
void dualMotorTurn(float robotDegrees, float power, bool direction, bool isRegulated) //robot turns using both motors
{
	float encoderCounts = ( TRACK_DISTANCE / DIAMETER) * robotDegrees * 4;

	// PID control at low speeds have problems for turning. Use higher power (>60)

	if(isRegulated){
		nMotorPIDSpeedCtrl[LeftWheels] = mtrSpeedReg;
		nMotorPIDSpeedCtrl[RightWheels] = mtrSpeedReg;
	}else{
			nMotorPIDSpeedCtrl[LeftWheels] = mtrNoReg;
			nMotorPIDSpeedCtrl[RightWheels] = mtrNoReg;
	}

	nMotorEncoder[LeftWheels] = 0;
	nMotorEncoder[RightWheels] = 0;

	if (direction)	// Turns robot clockwise or counter-clockwise, depending on user input
	{
		nMotorEncoderTarget[LeftWheels] = -1 * encoderCounts;
		nMotorEncoderTarget[RightWheels] = encoderCounts;
		motor[LeftWheels] = -1 * power;
		motor[RightWheels] = power;
	}
	else
	{
		nMotorEncoderTarget[LeftWheels] = encoderCounts;
		nMotorEncoderTarget[RightWheels] = -1 * encoderCounts;
		motor[LeftWheels] = power;
		motor[RightWheels] = -1 * power;
	}

	while((nMotorRunState[LeftWheels] != runStateIdle) && (nMotorRunState[RightWheels] != runStateIdle))
	{

		//do nothing while we wait for motors to spin to correct angles.
	}

	//stop the motors
	motor[LeftWheels] = 0;
	motor[RightWheels] = 0;

	//set back to unregulated gmotors just so we dont have the wrong mode when exiting
	nMotorPIDSpeedCtrl[LeftWheels] = mtrNoReg;
	nMotorPIDSpeedCtrl[RightWheels] = mtrNoReg;
}

void moveLift(int encoderCounts)
{
	nMotorPIDSpeedCtrl[Lift] = mtrSpeedReg;
	CurrentPosition = nMotorEncoder[Lift];

	stopTask(holdPosition); // Release the Hold Position task, to allow movement

	servo[Gate] = GATE_CLOSED; // Close the gate, to ensure the safety of motion of the lift

	// Now check if we need to travel up or down.
	if(nMotorEncoder[Lift] > encoderCounts) // Need to move down
	{
		// Check if we are travelling below the lower goal, special handling, until counterweight deployed.
		LiftState = Running;
		nMotorEncoderTarget[Lift] = CurrentPosition - encoderCounts;
		motor[Lift] = -95;

		while(nMotorRunState[Lift] != runStateIdle && nMotorEncoder[Lift] >= LIFT_LOWER)
		{
			// Let the motor lift run until motor becomes idle on reaching target or we reach the last segment down if we reach the last segment down we want to slow down.
		}

		if(nMotorEncoder[Lift] > encoderCounts)
		{
			CurrentPosition=nMotorEncoder[Lift];
			// We are now below the height of the lower base and need to slow down to let the last segment fall slowly
			// This should only execute when the target is the base of the lift
			nMotorEncoderTarget[Lift] = CurrentPosition - encoderCounts;
			motor[Lift] = -30;
			while(nMotorRunState[Lift] != runStateIdle)
			{
				//let the motor reach the target
			}
		} // if(nMotorEncoder[Lift] > encoderCounts)
	} // if(nMotorEncoder[Lift] > encoderCounts)
	else if(nMotorEncoder[Lift] < encoderCounts) // Need to move up
	{
		nMotorEncoderTarget[Lift] = encoderCounts - CurrentPosition;
		motor[Lift] = 95;
		LiftState = Running;
		while(nMotorRunState[Lift] != runStateIdle)
		{
			//let the motor run till it reaches target
		}
	} // else if(nMotorEncoder[Lift]<encoderCounts)

	// If we are already at the EncoderValue target we don't have to do anything

	// Stop the motor
	motor[Lift] = 0;
	LiftState = Stopped;
	TargetPosition = encoderCounts;
	if(encoderCounts != LIFT_BASE)
	{
		// If it is at lift base we don't need to hold position as it will be supported already otherwise we lock on to the position
		startTask(holdPosition);
	}
	else // Not needed, just caution
	{
		stopTask(holdPosition);
	}
}

void readChoices() // Reads choices made in Choices.c
{
	TFileIOResult nIoResult;
	TFileHandle myFileHandle;
	short myFileSize = 10;
	short startingPositionShort;
	short delayShort;

	OpenRead(myFileHandle, nIoResult, DATA_FILE_NAME, myFileSize);

	if(nIoResult) // Error in opening file for read
	{
		// NEED A BACK-UP PLAN
		playTone(5000, 5);
		stopAllTasks();
	}

	//reads choices
	ReadShort(myFileHandle, nIoResult, startingPositionShort);
	ReadShort(myFileHandle, nIoResult, delayShort);
	Close(myFileHandle, nIoResult);

	//sets values depending on choices

	if(startingPositionShort == RAMP_START)
	{
		StartingPosition = Ramp;
	}
	else
	{
		StartingPosition = ParkingZone;
	}

	if(delayShort == NEED_DELAY)
	{
		isDelay = true;
	}
	else
	{
		isDelay = false;
	}
}

task IntegrateGyroHeading(){
  time1[T1]=0;
	while(true){
		while(time1[T1]<20){
				wait1Msec(1);
		}
		time1[T1]=0;
		readSensor(&gyroSensor);
		//add the current rotation reading to the previous readings dividing by time elapsed
		gyroHeading =gyroHeading+ (gyroSensor.rotation)*0.02;
	}

}
