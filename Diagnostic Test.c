#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     irseeker,       sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S3,     LiftLimitTouch, sensorTouch)
#pragma config(Motor,  mtr_S1_C1_1,     LeftWheels,    tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     Spindle,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     RightWheels,   tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     Lift,          tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Servo,  srvo_S1_C3_1,    servo1,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_5,    Hooks,                tServoStandard)
#pragma config(Servo,  srvo_S1_C3_6,    Gate,                 tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*////Gate

#include "hitechnic-irseeker-v2.h"

#define GATE_CLOSED 70
#define GATE_OPEN 150

//Goal Hooks
#define GOAL_HOOKS_OPEN 10
#define GOAL_HOOKS_CLOSED 180

void waitForButtonPress();
tHTIRS2 irSeeker;
bool hasErrors = false;

void testNXTBattery();
void testEXTBattery();
void testWheelMotors();
void testSpindleMotor();
void testLiftMotor();
void testGateServo();
void testHookServo();
void testIRBeacon();
void testLiftLimitSensor();

//Touch Sensor Values (may need to change)
#define TOUCH_SENSOR_PRESSED 1
#define TOUCH_SENSOR_NOT_PRESSED 0

/*
 1. Check Primary Battery and External Battery Voltage (We know it can be done because these are shown during the run.
 2. Check DC Motors. Check Encoders.
 3. Check Servo Motors. Check Servo Position Change.
 4. Check Touch Sensor (wait for it to be pressed and confirm).
 5. Check Spindle turn.
*/

task main()
{

	bool hasErrors = false;
	bool leftWheelsError = false;
	bool rightWheelsError = false;
	bool liftError = false;
	bool spindleError = false;
	bool hooksError = false;
	bool gateError = false;
	bool touchSensorError = false;



	testNXTBattery();
	testEXTBattery();
	testWheelMotors();
	testSpindleMotor();
	testLiftMotor();
	testGateServo();
	testHookServo();
	testIRBeacon();
	testLiftLimitSensor();

	// play tone to signal end of program

	eraseDisplay();
	if(hasErrors)
	{

		displayTextLine(1,"Has Errors!!!");
		playTone(6000, 15);


		}else{

		displayTextLine(1, "No errors.");
		playTone(3000, 5);
	}


	wait1Msec(3000);

}



void testNXTBattery()
{
	eraseDisplay();

	//test Batteries

	//NXT Battery

	displayTextLine(1, "Testing NXT Batt..");
	if(nAvgBatteryLevel <8000){
		hasErrors=true;
		displayTextLine(3, "NXT Batt Low !!!...");
		displayTextLine(5,"NXT Batt:%d",nAvgBatteryLevel);
		playTone(5000, 5);
		//wait for acknowledgement
		waitForButtonPress();

		}else{
		displayTextLine(3, "NXT Batt Ok !!!...");
		displayTextLine(5,"NXT Batt: %d",nAvgBatteryLevel);
		wait1Msec(1000);
	}

}

void testEXTBattery()
{
	eraseDisplay();

	//test External Battery

	displayTextLine(1, "Testing Ext Batt..");
	if(externalBatteryAvg <13000){
		hasErrors=true;
		displayTextLine(3, "EXT Batt Low !!!...");
		displayTextLine(4,"EXT Batt Lev:%d",externalBatteryAvg);
		if(externalBatteryAvg<0){
			displayTextLine(5,"EXT Batt Off ?");
			wait1Msec(2000);
		}
		playTone(8000, 5);
		//wait for acknowledgement
		waitForButtonPress();

	}

	if(externalBatteryAvg >13000){
		eraseDisplay();
		displayTextLine(3, "EXT Batt Ok !!!...");
		displayTextLine(5,"EXT Batt Lev:%d",externalBatteryAvg);
		wait1Msec(3000);
	}

}

void testWheelMotors()
{
	eraseDisplay();
	//Get wheel motors to be at rest positions
	motor[LeftWheels]=0;
	motor[RightWheels]=0;

	//reset all encoders
	nMotorEncoder[LeftWheels] = 0;
	nMotorEncoder[RightWheels] = 0;


	// test motors

	// test LeftWheels


	displayTextLine(1, "Testing Left Wheels ...");
	wait1Msec(1000);

	displayTextLine(1, "Current Battery Level:%f", nImmediateBatteryLevel); //in millivolts
	displayTextLine(2, "External Battery Voltage:%f", externalBattery);
	wait1Msec(500);

	eraseDisplay();


	motor[LeftWheels] = 20;
	wait1Msec(500);
	motor[LeftWheels] = 0;

	if(nMotorEncoder[LeftWheels] == 0)
	{
		// either motor or encoder is faulty

		hasErrors = true;
//<<<<<<< HEAD
		displayTextLine(3, "Left wheels error !!!...");
		playTone(100, 5);		//wait for acknowledgement
		waitForButtonPress();

//=======
		//leftWheelsError = true;
		displayTextLine(2, "Left wheels error");
		playTone(100, 5);
		wait1Msec(2000);
//>>>>>>> origin/autonomous-dev
	}


	eraseDisplay();

	// test RightWheels
	displayTextLine(1, "Testing Right Wheels...");
	wait1Msec(1000);

	motor[RightWheels] = 20;

	wait1Msec(500);
	motor[RightWheels] = 0;

	if (nMotorEncoder[RightWheels] == 0)
	{
		// either motor or encoder is faulty

		hasErrors = true;
//<<<<<<< HEAD
		displayTextLine(3, "Right wheels error....");
//=======
		//rightWheelsError = true;
		displayTextLine(2, "Right wheels error");
//>>>>>>> origin/autonomous-dev
		playTone(500, 5);
		//wait for acknowledgement
		waitForButtonPress();
	}
//<<<<<<< HEAD
}

void testLiftMotor()
{
//=======

//>>>>>>> origin/autonomous-dev
	eraseDisplay();

	motor[Lift]=0;
	nMotorEncoder[Lift] = 0;

	//set an encoder target for the lift

	displayTextLine(1, "Testing Lift...");
	wait1Msec(1000);
	nMotorEncoderTarget[Lift]=500;
	motor[Lift] = 20;

	wait1Msec(500);
	motor[Lift] = 0;

	if (nMotorEncoder[Lift] == 0)
	{
		// either motor or encoder is faulty

		hasErrors = true;
//<<<<<<< HEAD
		displayTextLine(3, "Lift error....");
//=======
		//liftError = true;
		displayTextLine(2, "Lift error");
//>>>>>>> origin/autonomous-dev
		playTone(1000, 5);
		//wait for acknowledgement
		waitForButtonPress();
	}
	else
	{
		nMotorEncoderTarget[Lift]=0;
		motor[Lift] = -20;
		wait1Msec(500);
		motor[Lift] = 0;

	}

//<<<<<<< HEAD
}

void testSpindleMotor()
{
//=======
//>>>>>>> origin/autonomous-dev
	eraseDisplay();

	// test Spindle
	motor[Spindle]=0;


	displayTextLine(1, "Testing Spindle...");
	wait1Msec(1000);
	displayTextLine(2, "Conf Spindle Turn..");

	motor[Spindle] = 20;
	displayTextLine(1, "Testing Spindle");
	wait1Msec(500);
	motor[Spindle] = 0;
	//wait for acknowledgement
	waitForButtonPress();


}

void testHookServo()
{
	eraseDisplay();

	//reset encoder
	servo[Hooks]=GOAL_HOOKS_OPEN;


	if(motor[Spindle] == 0)
	{
		// either motor or encoder is faulty

		hasErrors = true;
		//spindleError = true;
		displayTextLine(2, "Spindle error");
		playTone(1000, 5);
		wait1Msec(2000);
	}
	else
	{
		motor[Spindle] = -20;
		wait1Msec(500);
		motor[Spindle] = 0;
		wait1Msec(2000);
	}

	eraseDisplay();

	// test Hooks

//<<<<<<< HEAD
	displayTextLine(1, "Testing Goal Hooks...");
	wait1Msec(1000);
	displayTextLine(2, "Conf GoalHook Close..");



	servo[Hooks] = GOAL_HOOKS_CLOSED;
	wait1Msec(500);
	//wait for acknowledgement
	waitForButtonPress();
	servo[Hooks]=GOAL_HOOKS_OPEN;

}

void testGateServo()
{
//=======
	servo[Hooks] = 180;
	displayTextLine(1, "Testing Hooks");
	wait1Msec(1000);

	if(servo[Hooks] == 0) //current servo position
	{
		hasErrors = true;
		//hooksError = true;
		displayTextLine(2, "Hooks error");
		playTone(600, 5);
		wait1Msec(2000);
	}
	else
	{
		servo[Hooks] = 10;
		wait1Msec(2000);
	}

	eraseDisplay();
//>>>>>>> origin/autonomous-dev

	eraseDisplay();
	// test Gate
	//set servos to starting position

//<<<<<<< HEAD
	servo[Gate]=GATE_CLOSED;


	displayTextLine(1, "Testing Gate Servo...");
	wait1Msec(1000);
	displayTextLine(2, "Conf Gate Open..");



	servo[Gate]= GATE_OPEN;
	wait1Msec(500);
	//wait for acknowledgement
	waitForButtonPress();
	servo[Gate]= GATE_CLOSED;

}

void testIRBeacon()
{

	eraseDisplay();

	//Test IR Beacon
	displayTextLine(1, "Testing IR Becon...");
	wait1Msec(1000);
	//initialize Beacon
	initSensor(&irSeeker, S2);
	wait1Msec(1000);
	irSeeker.mode=DSP_1200;

	displayTextLine(1, "Testing Gate");
	servo[Gate] = 50;
	wait1Msec(1000);

	if(servo[Gate] == 0)
	{
		hasErrors = true;
		//gateError = true;
		displayTextLine(2, "Gate errors");
		playTone(700, 5);
		wait1Msec(2000);
	}
	else
	{
		servo[Gate] = 70;
		wait1Msec(1000);
	}

	eraseDisplay();

	while(SensorValue[LiftLimitTouch] == TOUCH_SENSOR_NOT_PRESSED)
	{
		motor[Lift] = 20;
		displayTextLine(1, "Testing Touch Sensor");
	}
	if(SensorValue[LiftLimitTouch] == TOUCH_SENSOR_PRESSED)
	{
		displayTextLine(2, "Touch sensor pressed");
		motor[Lift] = -20;
		wait1Msec(2000);
	}
	else
	{
		hasErrors = true;
		//touchSensorError = true;
		displayTextLine(2, "Touch sensor error");
		wait1Msec(2000);
	}

	eraseDisplay();


	displayTextLine(2, "Set IRBeacon=1200");
	displayTextLine(3, "Hold IRB in front");

	//Testing at 1200
	irSeeker.acDirection=0;
	displayTextLine(4,"Reading IR Sensor..");
	clearTimer(T1);
	while((irSeeker.acDirection==0)&&(time1[T1]<10000)&&(nNxtButtonPressed<0)){
		readSensor(&irSeeker);
	}
	if((time1[T1]>=10000)||(nNxtButtonPressed>=0)){
		//timer ran out or interrupted
		hasErrors=true;
		displayTextLine(5,"Could not find IR Beacon");
		//wait for confirmation
		wait1Msec(1000);
		waitForButtonPress();
		}else{
		//found IR Beacon
		displayTextLine(5,"Found IR, Dir:%d",irSeeker.acDirection);
		wait1Msec(2000);
	}

}


void testLiftLimitSensor()
{

	eraseDisplay();
	//test for Touch Sensor

	displayTextLine(1, "Testing LiftLimit Sensor...");
	wait1Msec(1000);
	displayTextLine(2, "Press LiftLimit Sensor..");
	clearTimer(T1);
	while((SensorValue[LiftLimitTouch]==0)&&(time1[T1]<10000)&&(nNxtButtonPressed<0)){
		//intentional
	}
	if((time1[T1]>=10000)||(nNxtButtonPressed>=0)){
		//timer ran out or we were interrupted
		hasErrors=true;
		displayTextLine(5,"No LiftLimit Sensed");
		//wait for confirmation
		wait1Msec(1000);
		waitForButtonPress();
		}else{
		displayTextLine(5,"Detected LiftLimit Press");
		wait1Msec(2000);
	}

}


void waitForButtonPress()
{
	displayTextLine(6,"Press any btn..");
	while(nNxtButtonPressed<0){
		//intentional. will run till a button is pressed
	}
	//absorbing button press buffer persistence
	wait1Msec(1000);
}
