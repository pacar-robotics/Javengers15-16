#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     irseeker,       sensorHiTechnicIRSeeker1200)
#pragma config(Motor,  motorA,           ,             tmotorNXT, openLoop, encoder)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop, encoder)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     LeftWheels,    tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     Spindle,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     RightWheels,   tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     Lift,          tmotorTetrix, openLoop, encoder)
#pragma config(Servo,  srvo_S1_C3_1,    servo1,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_5,    Hooks,                tServoStandard)
#pragma config(Servo,  srvo_S1_C3_6,    Gate,                 tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"
#include "hitechnic-irseeker-v2.h"	//used for IR Seeker

// Robot and Field Definitions

// IR Frequencies
#define IR600 DSP_600
#define IR1200 DSP_1200

// Buttons
#define LEFT_BUTTON 2
#define RIGHT_BUTTON 1

// Measurements
#define DIAMETER 7.62
#define TRACK_DISTANCE 48
#define RAMP_DISTANCE 150

// Directions
#define FORWARD true
#define BACKWARD false
#define CLOCKWISE true
#define COUNTER_CLOCKWISE false

// Lift
#define LIFT_MAX 22300
#define LIFT_TOP 22250
#define LIFT_MIDDLE 14350
#define LIFT_LOWER 7150
#define LIFT_BASE 0

// Gate
#define GATE_CLOSED 180
#define GATE_OPEN 10

// Goal Finger Positions
#define GOAL_HOOKS_OPEN 10
#define GOAL_HOOKS_CLOSED 180

//delay
#define DELAY_TIME 10000

//used to regulate motors
#define REGULATED true
#define UNREGULATED false

//file used in Choice.c
#define DATA_FILE_NAME "choices.txt"

#define RAMP_START 1
#define PARKING_ZONE 0

#define NEED_DELAY 1
#define NO_DELAY 0


//Functions
void readChoices();	//reads choices made in Choices.c
void rampFunction();	//goes down the ramp to collect goals
void kickstand();		//kicks kickstand
void initializeRobot();
void calcMove(float centimeters, float power, bool direction, bool isRegulated);
void dualMotorTurn(float robotDegrees, float power, bool direction);

//for irSeeker
tHTIRS2 irSeeker;
tHTIRS2DSPMode irFrequency;

bool isDelay;

enum StartingPositionEnum {ParkingZone, Ramp};
//enum LiftStateEnum {Running, Stopped};

StartingPositionEnum StartingPosition;
//LiftStateEnum LiftState;

task main()
{
	initializeRobot();
	readChoices(); // Reads choices from a file that is written in from a program called Choices

	// If irFrequency equals IR600, then let it stay IR600, else, let it be IR1200
	irSeeker.mode = irFrequency;
	waitForStart();

	if(isDelay)	//if there is a delay wait
	{
		wait1Msec(DELAY_TIME);
	}

	if(StartingPosition == Ramp)
	{
		rampFunction();
	}
	else if(StartingPosition == ParkingZone)
	{
		kickstand();
	}
}

// Functions

void initializeRobot()
{
	servo[Gate] = GATE_CLOSED;
	servo[Hooks] = GOAL_HOOKS_OPEN;
	initSensor(&irSeeker, S2);
	nMotorEncoder[LeftWheels] = 0;
	nMotorEncoder[RightWheels] = 0;
}

void rampFunction() //ramp, goals
{
	calcMove(RAMP_DISTANCE, 50, BACKWARD, REGULATED);		//goes down ramp
	dualMotorTurn(3, 40, CLOCKWISE);
	calcMove(60, 90, BACKWARD, REGULATED);
	servo[Hooks] = GOAL_HOOKS_CLOSED; // Grabs the goal
	wait1Msec(300); // Waits because the servo has time to move before the wheels start moving
	dualMotorTurn(30, 40, CLOCKWISE);
	calcMove(215, 90, FORWARD, REGULATED);
	dualMotorTurn(180, 40, COUNTER_CLOCKWISE);
	servo[Hooks] = GOAL_HOOKS_OPEN; // Let go of goal and leaves it in PZ
	calcMove(250, 90, FORWARD, REGULATED);
	dualMotorTurn(180, 40, CLOCKWISE);
}

void kickstand()	//kicks kickstand depending on directional value of irseeker
{
	readSensor(&irSeeker); // Reads the IR sensor values

	switch(irSeeker.acDirection) // NEED TO RE-CHECK VALUES
	{
		case 0:	// for Position 1
			calcMove(40, 50, FORWARD, REGULATED);
			dualMotorTurn(40, 40, COUNTER_CLOCKWISE);
			calcMove(105, 50, FORWARD, REGULATED);
			dualMotorTurn(130, 40, CLOCKWISE);
			calcMove(55, 60, FORWARD, REGULATED);
			dualMotorTurn(90, 40, CLOCKWISE);
			break;

		case 3:	// for Position 2
			calcMove(100, 50, FORWARD, REGULATED);
			dualMotorTurn(30, 40, CLOCKWISE);
			calcMove(25, 50, FORWARD, REGULATED);
			dualMotorTurn(45, 70, CLOCKWISE);
			break;

		case 5:	// for Position 3
			calcMove(30, 50, FORWARD, REGULATED);
			dualMotorTurn(30, 40, CLOCKWISE);
			calcMove(60, 50, FORWARD, REGULATED);
			dualMotorTurn(32, 40, COUNTER_CLOCKWISE);
			calcMove(67, 50, FORWARD, REGULATED);
			dualMotorTurn(90, 40, CLOCKWISE);
			break;
	}	//switch
}

// for moving forward and backword
void calcMove(float centimeters, float power, bool direction, bool isRegulated)
{
	float encoder_counts;

	if(isRegulated)	//turns on pid control (originally in pragma statements)
	{
		nMotorPIDSpeedCtrl[LeftWheels] = mtrSpeedReg;
		nMotorPIDSpeedCtrl[RightWheels] = mtrSpeedReg;
	}
	else
	{
		nMotorPIDSpeedCtrl[LeftWheels] = mtrNoReg;
		nMotorPIDSpeedCtrl[RightWheels] = mtrNoReg;
	}

	// Resets encoders
	nMotorEncoder[LeftWheels] = 0;
	nMotorEncoder[RightWheels] = 0;

	encoder_counts = (centimeters / (DIAMETER * PI)) * 1440; // converts centimeters to motor encoder counts

	if (!direction) //check for direction.
	{
		power = -1 * power;
		encoder_counts = -1 * encoder_counts;
	}

	//set the target encoder values before we set power to start motors.
	nMotorEncoderTarget[LeftWheels] = encoder_counts;
	nMotorEncoderTarget[RightWheels] = encoder_counts;

	motor[LeftWheels] = power;
	motor[RightWheels] = power;

	while((nMotorRunState[LeftWheels] != runStateIdle) && (nMotorRunState[RightWheels] != runStateIdle))
	{
		// Do nothing while we wait for motors to spin to correct distance.
	}

	//stop the motors
	motor[LeftWheels] = 0;
	motor[RightWheels] = 0;

	//set back to unregulated gmotors just so we dont have the wrong mode when exiting
	nMotorPIDSpeedCtrl[LeftWheels] = mtrNoReg;
	nMotorPIDSpeedCtrl[RightWheels] = mtrNoReg;
}

//for turning with two wheels
void dualMotorTurn(float robotDegrees, float power, bool direction) //robot turns using both motors
{
	int encoderCounts = ( TRACK_DISTANCE / DIAMETER) * robotDegrees * 4;

	// Set motors to No PID control as differential turns have problems
	nMotorPIDSpeedCtrl[LeftWheels] = mtrNoReg;
	nMotorPIDSpeedCtrl[RightWheels] = mtrNoReg;

	nMotorEncoder[LeftWheels] = 0;
	nMotorEncoder[RightWheels] = 0;

	if (direction)	// Turns robot clockwise or counter-clockwise, depending on user input
	{
		nMotorEncoderTarget[LeftWheels] = -1 * encoderCounts;
		nMotorEncoderTarget[RightWheels] = encoderCounts;
		motor[LeftWheels] = -1 * power;
		motor[RightWheels] = power;
	}
	else
	{
		nMotorEncoderTarget[LeftWheels] = encoderCounts;
		nMotorEncoderTarget[RightWheels] = -1 * encoderCounts;
		motor[LeftWheels] = power;
		motor[RightWheels] = -1 * power;
	}

	while((nMotorRunState[LeftWheels] != runStateIdle) && (nMotorRunState[RightWheels] != runStateIdle))
	{
  	//do nothing while we wait for motors to spin to correct angles.
  }

	//stop the motors
	motor[LeftWheels] = 0;
	motor[RightWheels] = 0;

	//set back to unregulated gmotors just so we dont have the wrong mode when exiting
	nMotorPIDSpeedCtrl[LeftWheels] = mtrNoReg;
	nMotorPIDSpeedCtrl[RightWheels] = mtrNoReg;
}

//reads choices made in Choices.c
void readChoices()
{
	TFileIOResult nIoResult;
	TFileHandle myFileHandle;
	short myFileSize = 10;
	short irChoice;
	short startingPositionShort;
	short delayShort;

	OpenRead(myFileHandle, nIoResult, DATA_FILE_NAME, myFileSize);

	if(nIoResult) // Error in opening file for read
	{
		// NEED A BACK-UP PLAN
		playTone(5000, 5);
	  stopAllTasks();
	}

	//reads choices
	ReadShort(myFileHandle, nIoResult, irChoice);
	ReadShort(myFileHandle, nIoResult, startingPositionShort);
	ReadShort(myFileHandle, nIoResult, delayShort);
	Close(myFileHandle, nIoResult);

	//sets values depending on choices
	if(irChoice == 1200)
	{
		irFrequency = IR1200;
	}
	else
	{
		irFrequency = IR600;
	}

	if(startingPositionShort == RAMP_START)
	{
		StartingPosition = Ramp;
	}
	else
	{
		StartingPosition = ParkingZone;
	}


	if(delayShort == NEED_DELAY)
	{
		isDelay = true;
	}
	else
	{
		isDelay = false;
	}
}
