#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     HTIRS2,         sensorI2CCustom)
#pragma config(Motor,  motorA,           ,             tmotorNXT, openLoop, encoder)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop, encoder)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     LeftWheels,    tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     Spindle,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     RightWheels,   tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     Lift,          tmotorTetrix, openLoop, encoder)
#pragma config(Servo,  srvo_S1_C3_1,    servo1,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_6,    Gate,                 tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define FOO 0

//robot and field definitions
#define DIAMETER 6.985
#define TRACK_DISTANCE 19.304
#define RAMP_DISTANCE 190

#define FORWARD true
#define BACKWARD false
#define CLOCKWISE true
#define COUNTER_CLOCKWISE false

//Lift
#define LIFT_MAX 22300
#define LIFT_TOP 22250
#define LIFT_MIDDLE 14350
#define LIFT_LOWER 7150
#define LIFT_BASE 0

//Gate
#define GATE_CLOSED 50
#define GATE_OPEN 150

#include "JoystickDriver.c"
#include "hitechnic-irseeker-v2.h"

//Functions
void rampRobot();
void initializeRobot();
void calcMove(float centimeters, float power, bool direction);
void dualMotorTurn(float robotDegrees, float power, bool direction);
void kickstand();
void grabGoalBase();
void moveLift(int encoderCounts);

enum LiftStateEnum {Running, Stopped};

LiftStateEnum LiftState;

task main()
{
	initializeRobot();

	nMotorEncoder[LeftWheels] = 0;
	nMotorEncoder[RightWheels] = 0;

	//waitForStart();

	//kickstand();

	dualMotorTurn(90, 40, COUNTER_CLOCKWISE);
	wait1Msec(10000);
	calcMove(50, 40, FORWARD);
}


/*	Functions:	*/

void rampRobot()
{
	calcMove(RAMP_DISTANCE, 50, FORWARD);		//goes down ramp
	calcMove(FOO, 50, FORWARD);			//goes to nearest goal (middle)
	grabGoalBase();
	moveLift(LIFT_MIDDLE);			//puts two balls in the middle goal
	servo[Gate]=GATE_OPEN;
	wait1Msec(3000);
	servo[Gate]=GATE_CLOSED;
	moveLift(LIFT_BASE);
}

void grabGoalBase()
{
	//stub
}


void kickstand()
{
	tHTIRS2 irSeeker;
	initSensor(&irSeeker, S2);
	irSeeker.mode=DSP_600;

	dualMotorTurn(100, 40, CLOCKWISE);
	calcMove(40, 40, FORWARD);
	dualMotorTurn(100, 40, CLOCKWISE);
	calcMove(100, 40, FORWARD);

	while(irSeeker.acDirection != 5)
	{
		readSensor(&irSeeker);
		motor[LeftWheels] = -20;
		motor[RightWheels] = 20;
	}
}

void moveLift(int encoderCounts)
{
	if(nMotorEncoder[Lift]>encoderCounts)
	{
		LiftState= Running;
		motor[Lift]= -65;
		while((nMotorEncoder[Lift]>encoderCounts)&&(nMotorEncoder[Lift]>LIFT_LOWER))
		{
			//idle loop
		}

		if(nMotorEncoder[Lift]>encoderCounts)
		{
			motor[Lift]=-30;
			while(nMotorEncoder[Lift]>encoderCounts)
			{
				//idle
			}
		}
	}
	else if(nMotorEncoder[Lift]<encoderCounts)
	{
		motor[Lift]= 80;
		LiftState= Running;
		while(nMotorEncoder[Lift]<encoderCounts)
		{
			//idle
		}
	}

	motor[Lift]=0;
	LiftState=Stopped;
}

void calcMove(float centimeters, float power, bool direction)
{
	float encoder_counts;

	encoder_counts = (centimeters/31.9024) * 1440; // converts centimeters to motor encoder counts

	while(nMotorEncoder[LeftWheels] < abs(encoder_counts) || nMotorEncoder[RightWheels] < abs(encoder_counts))
	{
		if (direction) // robot will move forward
		{
			motor[LeftWheels] = power;
			motor[RightWheels] = power;
		}
		else // robot will move backward
		{
			motor[LeftWheels] = -1 * power;
			motor[RightWheels] = -1 * power;
		}
	}
}


void dualMotorTurn(float robotDegrees, float power, bool direction) //robot turns using both motors
{
	int encoderCounts = (TRACK_DISTANCE/DIAMETER*(robotDegrees*4))*2;
	nMotorEncoder[LeftWheels] = 0;
	nMotorEncoder[RightWheels] = 0;
	if (direction == CLOCKWISE)	//turns robot clockwise or counter-clockwise, depending on user input
	{
		//nMotorEncoderTarget[LeftWheels] = encoderCounts;
		//nMotorEncoderTarget[RightWheels] = -1*encoderCounts;
		motor[LeftWheels] = power;
		motor[RightWheels] = -1 * power;
		/*while((nMotorEncoder[LeftWheels] < encoderCounts) || (nMotorEncoder[RightWheels] > -1*encoderCounts))
		{
			// idle loop
		}*/
	}
	else
	{
		//nMotorEncoderTarget[LeftWheels] = -1*encoderCounts;
		//nMotorEncoderTarget[RightWheels] = encoderCounts;
		motor[LeftWheels] = -1* power;
		motor[RightWheels] = power;
		/*while((nMotorEncoder[LeftWheels] > -1*encoderCounts) || (nMotorEncoder[RightWheels] < encoderCounts))
		{
			// idle loop
		}*/
	}
	while((nMotorEncoder[LeftWheels]<abs(encoderCounts))&&(nMotorEncoder[RightWheels]<abs(encoderCounts)))
	{
		//
	}
	motor[LeftWheels] = 0;
	motor[RightWheels] = 0;
}

void initializeRobot()
{
	return;
}
