#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     irseeker,       sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S3,     LiftLimitTouch, sensorTouch)
#pragma config(Motor,  motorA,           ,             tmotorNXT, openLoop, encoder)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop, encoder)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     LeftWheels,    tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     Spindle,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     RightWheels,   tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     Lift,          tmotorTetrix, openLoop, encoder)
#pragma config(Servo,  srvo_S1_C3_1,    servo1,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_5,    Hooks,                tServoStandard)
#pragma config(Servo,  srvo_S1_C3_6,    Gate,                 tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//#include "JoystickDriver.c"
#include "hitechnic-irseeker-v2.h"

// Robot and Field Definitions

// IR Frequencies
#define IR600 DSP_600
#define IR1200 DSP_1200

// Buttons
#define LEFT_BUTTON 2
#define RIGHT_BUTTON 1

// Measurements
#define DIAMETER 7.62
#define TRACK_DISTANCE 48
#define RAMP_DISTANCE 150

// Directions
#define FORWARD true
#define BACKWARD false
#define CLOCKWISE true
#define COUNTER_CLOCKWISE false

// Lift
#define LIFT_MAX 22300
#define LIFT_TOP 22250
#define LIFT_MIDDLE 14350
#define LIFT_LOWER 7150
#define LIFT_BASE 0
#define LIFT_HOLD_POSITION_POWER 5

// Gate
#define GATE_CLOSED 180
#define GATE_OPEN 10

// Goal Finger Positions
#define GOAL_HOOKS_OPEN 10
#define GOAL_HOOKS_CLOSED 180

#define DELAY_TIME 10000

#define REGULATED true
#define UNREGULATED false

#define DATA_FILE_NAME "choices.txt"

#define RAMP_START 1
#define PARKING_ZONE 0

#define NEED_DELAY 1
#define NO_DELAY 0


//Functions
void readChoices();
void rampFunction();
void initializeRobot();
void calcMove(float centimeters, float power, bool direction, bool isRegulated);
void dualMotorTurn(float robotDegrees, float power, bool direction);
void kickstand();
void moveLift(int encoderCounts);
task holdPosition();
task LiftSafetyUpperLimitWatch();
task LiftSafetyLowerLimitWatch();
task LiftSafetyLimitTouchWatch();


//void displayIRBeaconValues();

//for irSeeker
tHTIRS2 irSeeker;
tHTIRS2DSPMode irFrequency;
int TargetPosition;
int CurrentPosition;


bool isDelay;

enum StartingPositionEnum {ParkingZone, Ramp};

enum LiftStateEnum {Running, Stopped}; // State of Lift
//enum GateStateEnum {Open, Closed}; // State of gate

StartingPositionEnum StartingPosition;
LiftStateEnum LiftState;

task main()
{
	initializeRobot();


	waitForStart();
	startTask(LiftSafetyUpperLimitWatch);
  startTask(LiftSafetyLowerLimitWatch);
	startTask(LiftSafetyLimitTouchWatch);


	if(isDelay)
	{
		wait1Msec(DELAY_TIME);
	}

	if(StartingPosition == Ramp)
	{
		rampFunction();
	}
	else if(StartingPosition == ParkingZone)
	{
		kickstand();
	}
}

// Functions

void initializeRobot()
{
	servo[Gate] = GATE_CLOSED;
	servo[Hooks] = GOAL_HOOKS_OPEN;
	initSensor(&irSeeker, S2);
	wait1Msec(100);
	nMotorEncoder[LeftWheels] = 0;
	nMotorEncoder[RightWheels] = 0;
	nNoMessageCounterLimit = 150; //shortens time taken to stop robot.
	readChoices();
	irSeeker.mode = (irFrequency == IR600 ? DSP_600: DSP_1200);

  LiftState=Stopped;

  nMotorEncoder[Lift]=0;
}

void rampFunction() //ramp, goals
{
	calcMove(RAMP_DISTANCE, 50, BACKWARD, REGULATED);		//goes down ramp
	dualMotorTurn(3, 40, CLOCKWISE);
	calcMove(60, 90, BACKWARD, REGULATED);
	servo[Hooks] = GOAL_HOOKS_CLOSED; // Grabs the goal
	wait1Msec(300); // Waits because the servo has time to move before the wheels start moving
	moveLift(LIFT_MIDDLE);			//puts two balls in the middle goal
	servo[Gate]=GATE_OPEN;
	wait1Msec(3000);
	servo[Gate]=GATE_CLOSED;
	moveLift(LIFT_BASE);
	dualMotorTurn(30, 40, CLOCKWISE);
	calcMove(215, 90, FORWARD, REGULATED);
	dualMotorTurn(180, 40, COUNTER_CLOCKWISE);
	servo[Hooks] = GOAL_HOOKS_OPEN; // Let go of goal and leaves it in PZ
	calcMove(250, 90, FORWARD, REGULATED);
	dualMotorTurn(180, 40, CLOCKWISE);
}

void kickstand()	//kicks kickstand
{
	readSensor(&irSeeker); // Reads the IR sensor values
	switch(irSeeker.acDirection) // NEED TO RE-CHECK VALUES
	{
	case 0:	// Position 1
		calcMove(40, 50, FORWARD, REGULATED);
		dualMotorTurn(60, 40, COUNTER_CLOCKWISE);
		calcMove(105, 50, FORWARD, REGULATED);
		dualMotorTurn(160, 40, CLOCKWISE);
		calcMove(35, 60, FORWARD, REGULATED);
		dualMotorTurn(90, 40, CLOCKWISE);
		break;

	case 3:	// Position 2
		calcMove(130, 50, FORWARD, REGULATED);
		dualMotorTurn(75, 40, CLOCKWISE);
		calcMove(5, 50, FORWARD, REGULATED);
		dualMotorTurn(45, 70, CLOCKWISE);
		break;

	case 5:	// Position 3
		calcMove(30, 50, FORWARD, REGULATED);
		dualMotorTurn(30, 40, CLOCKWISE);
		calcMove(60, 50, FORWARD, REGULATED);
		dualMotorTurn(32, 40, COUNTER_CLOCKWISE);
		calcMove(67, 50, FORWARD, REGULATED);
		dualMotorTurn(90, 40, CLOCKWISE);
		break;
	}
}


void calcMove(float centimeters, float power, bool direction, bool isRegulated)
{
	float encoder_counts;
	int prevLeftEncoderValue=0;
	int prevRightEncoderValue=0;
	int leftStallCount=0;
	int rightStallCount=0;
	bool rightStalled=false;
	bool leftStalled=false;

	if(isRegulated)
	{
		nMotorPIDSpeedCtrl[LeftWheels] = mtrSpeedReg;
		nMotorPIDSpeedCtrl[RightWheels] = mtrSpeedReg;
	}
	else
	{
		nMotorPIDSpeedCtrl[LeftWheels] = mtrNoReg;
		nMotorPIDSpeedCtrl[RightWheels] = mtrNoReg;
	}

	// Resets encoders
	nMotorEncoder[LeftWheels] = 0;
	nMotorEncoder[RightWheels] = 0;

	encoder_counts = (centimeters/(DIAMETER*PI)) * 1440; // converts centimeters to motor encoder counts

	if (!direction) //check for direction.
	{
		power = -1 * power;
		encoder_counts = -1 * encoder_counts;
	}

	//set the target encoder values before we set power to start motors.
	nMotorEncoderTarget[LeftWheels] = encoder_counts;
	nMotorEncoderTarget[RightWheels] = encoder_counts;

	motor[LeftWheels] = power;
	motor[RightWheels] = power;

	prevLeftEncoderValue=0;
	prevRightEncoderValue=0;
	leftStallCount=0;
	rightStallCount=0;

	while((nMotorRunState[LeftWheels] != runStateIdle) && (nMotorRunState[RightWheels] != runStateIdle)&&
		     (!rightStalled)&&(!leftStalled))
	{
		//Check for stall of left wheels
		if(abs(power)>0){
			if (abs(nMotorEncoder(LeftWheels)-prevLeftEncoderValue)<2){
				leftStallCount++;
			}else{
				leftStallCount=0;
			}
			prevLeftEncoderValue=nMotorEncoder[LeftWheels];
		}
		if(leftStallCount>1500){
			//LeftMotor Likely stalled
			motor[LeftWheels]=0;
			leftStalled=true;
			playTone(5000,5);
			break;
		}

		//Check for stall of right wheels
		if(abs(power)>0){
			if (abs(nMotorEncoder(RightWheels)-prevRightEncoderValue)<2){
				rightStallCount++;
			}else{
				rightStallCount=0;
			}
			prevRightEncoderValue=nMotorEncoder[RightWheels];
		}
		if(rightStallCount>1500){
			//RightMotor Likely stalled
			motor[RightWheels]=0;
			rightStalled=true;
			playTone(10000,5);
			break;
		}

	}

	//stop the motors
	motor[LeftWheels] = 0;
	motor[RightWheels] = 0;

	//set back to unregulated gmotors just so we dont have the wrong mode when exiting
	nMotorPIDSpeedCtrl[LeftWheels] = mtrNoReg;
	nMotorPIDSpeedCtrl[RightWheels] = mtrNoReg;
}

void dualMotorTurn(float robotDegrees, float power, bool direction) //robot turns using both motors
{
	int encoderCounts = ( TRACK_DISTANCE / DIAMETER) * robotDegrees * 4;

	int prevLeftEncoderValue=0;
	int prevRightEncoderValue=0;
	int leftStallCount=0;
	int rightStallCount=0;
	bool rightStalled=false;
	bool leftStalled=false;


	// Set motors to No PID control as differential turns have problems
	nMotorPIDSpeedCtrl[LeftWheels] = mtrNoReg;
	nMotorPIDSpeedCtrl[RightWheels] = mtrNoReg;

	nMotorEncoder[LeftWheels] = 0;
	nMotorEncoder[RightWheels] = 0;

	if (direction)	// Turns robot clockwise or counter-clockwise, depending on user input
	{
		nMotorEncoderTarget[LeftWheels]=-1*encoderCounts;
		nMotorEncoderTarget[RightWheels]=encoderCounts;
		motor[LeftWheels] = -1 * power;
		motor[RightWheels] = power;
	}
	else
	{
		nMotorEncoderTarget[LeftWheels]=encoderCounts;
		nMotorEncoderTarget[RightWheels]=-1*encoderCounts;
		motor[LeftWheels] = power;
		motor[RightWheels] = -1 * power;
	}

	prevLeftEncoderValue=0;
	prevRightEncoderValue=0;
	leftStallCount=0;
	rightStallCount=0;


	while((nMotorRunState[LeftWheels] != runStateIdle) && (nMotorRunState[RightWheels] != runStateIdle)&&
		    (!leftStalled)&&(!rightStalled))
	{
		//Check for stall of left wheels
		if(abs(power)>0){
			if (abs(nMotorEncoder(LeftWheels)-prevLeftEncoderValue)<2){
				leftStallCount++;
			}else{
				leftStallCount=0;
			}
			prevLeftEncoderValue=nMotorEncoder[LeftWheels];
		}
		if(leftStallCount>1500){
			//LeftMotor Likely stalled
			motor[LeftWheels]=0;
			leftStalled=true;
			playTone(5000,5);
			break;
		}

		//Check for stall of right wheels
		if(abs(power)>0){
			if (abs(nMotorEncoder(RightWheels)-prevRightEncoderValue)<2){
				rightStallCount++;
			}else{
				rightStallCount=0;
			}
			prevRightEncoderValue=nMotorEncoder[RightWheels];
		}
		if(rightStallCount>1500){
			//RightMotor Likely stalled
			motor[RightWheels]=0;
			rightStalled=true;
			playTone(10000,5);
			break;
		}


  }

	//stop the motors
	motor[LeftWheels] = 0;
	motor[RightWheels] = 0;

	//set back to unregulated gmotors just so we dont have the wrong mode when exiting
	nMotorPIDSpeedCtrl[LeftWheels] = mtrNoReg;
	nMotorPIDSpeedCtrl[RightWheels] = mtrNoReg;
}

void readChoices()
{
	TFileIOResult nIoResult;
	TFileHandle myFileHandle;
	short myFileSize = 10;
	short irChoice;
	short startingPositionShort;
	short delayShort;

	OpenRead(myFileHandle, nIoResult, DATA_FILE_NAME, myFileSize);

	if(nIoResult) // Error in opening file for read
	{
		// NEED A BACK-UP PLAN
		playTone(5000, 5);
	  stopAllTasks();
	}

	ReadShort(myFileHandle, nIoResult, irChoice);
	ReadShort(myFileHandle, nIoResult, startingPositionShort);
	ReadShort(myFileHandle, nIoResult, delayShort);
	Close(myFileHandle, nIoResult);

	if(irChoice == 1200)
	{
		irFrequency = IR1200;
	}
	else
	{
		irFrequency = IR600;
	}

	if(startingPositionShort == RAMP_START)
	{
		StartingPosition = Ramp;
	}
	else
	{
		StartingPosition = ParkingZone;
	}

	if(delayShort == NEED_DELAY)
	{
		isDelay = true;
	}
	else
	{
		isDelay = false;
	}

	eraseDisplay();
	displayTextLine(1, "Freq: %d", irChoice);
	displayTextLine(2, "Start: %s", (startingPositionShort == RAMP_START ? "Ramp" : "PZ"));
	displayTextLine(3, "Delay: %s", (delayShort == NEED_DELAY ? "Yes" : "No"));
	wait1Msec(5000);
	eraseDisplay();
}

task holdPosition()
{
	while(true) // Constantly checks
	{
		if(nMotorEncoder[Lift] > TargetPosition) // if higher than supposed to be, lower it
		{
			motor[Lift] = -1 * LIFT_HOLD_POSITION_POWER;
		}

		if(nMotorEncoder[Lift] < TargetPosition) // if lower than supposed to be, raise it
		{
			motor[Lift] = LIFT_HOLD_POSITION_POWER;
		}
	} // while(true)
} // task holdPosition()


void moveLift(int encoderCounts)
{
	nMotorPIDSpeedCtrl[Lift] = mtrSpeedReg;
	CurrentPosition = nMotorEncoder[Lift];

	stopTask(holdPosition); // Release the Hold Position task, to allow movement

	servo[Gate] = GATE_CLOSED; // Close the gate, to ensure the safety of motion of the lift

	// Now check if we need to travel up or down.
	if(nMotorEncoder[Lift] > encoderCounts) // Need to move down
	{
		// Check if we are travelling below the lower goal, special handling, until counterweight deployed.
		LiftState = Running;
		nMotorEncoderTarget[Lift] = CurrentPosition - encoderCounts;
		motor[Lift] = -75;

		while(nMotorRunState[Lift] != runStateIdle && nMotorEncoder[Lift] >= LIFT_LOWER)
		{
			// Let the motor lift run until motor becomes idle on reaching target or we reach the last segment down if we reach the last segment down we want to slow down.
		}

		if(nMotorEncoder[Lift] > encoderCounts)
		{
			CurrentPosition=nMotorEncoder[Lift];
			// We are now below the height of the lower base and need to slow down to let the last segment fall slowly
			// This should only execute when the target is the base of the lift
			nMotorEncoderTarget[Lift] = CurrentPosition - encoderCounts;
			motor[Lift] = -30;
			while(nMotorRunState[Lift] != runStateIdle)
			{
				//let the motor reach the target
			}
		} // if(nMotorEncoder[Lift] > encoderCounts)
	} // if(nMotorEncoder[Lift] > encoderCounts)
	else if(nMotorEncoder[Lift] < encoderCounts) // Need to move up
	{
		nMotorEncoderTarget[Lift] = encoderCounts - CurrentPosition;
		motor[Lift] = 95;
		LiftState = Running;
		while(nMotorRunState[Lift] != runStateIdle)
		{
			//let the motor run till it reaches target
		}
	} // else if(nMotorEncoder[Lift]<encoderCounts)

	// If we are already at the EncoderValue target we don't have to do anything

	// Stop the motor
	motor[Lift] = 0;
	LiftState = Stopped;
	TargetPosition = encoderCounts;
	if(encoderCounts != LIFT_BASE)
	{
		// If it is at lift base we don't need to hold position as it will be supported already otherwise we lock on to the position
		startTask(holdPosition);
	}
	else // Not needed, just caution
	{
		stopTask(holdPosition);
	}
}

task LiftSafetyUpperLimitWatch(){
	while(1){
		if(nMotorEncoder[Lift]>LIFT_MAX){
			//stop the lift
			motor[Lift]=0;
			//move the lift back down to the limit.
			while(nMotorEncoder[Lift]>LIFT_MAX){
				motor[Lift]=-10;
				LiftState=Running;
			}
			//now stop the motor again.
			motor[Lift]=0;
			LiftState=Stopped;
		}
	}

}

task LiftSafetyLowerLimitWatch(){
	while(1){
		if(nMotorEncoder[Lift]<LIFT_BASE){
			//stop the lift
			motor[Lift]=0;
			//rewind the cable to zero
			while(nMotorEncoder[Lift]<LIFT_BASE){
				motor[Lift]=10;
				LiftState=Running;
			}
			//stop the motor again
			motor[Lift]=0;
			LiftState=Stopped;
		}
	}

}
task LiftSafetyLimitTouchWatch(){
	while(1){
		if(SensorValue[LiftLimitTouch]!=0){
			playTone(5000,5);
			//stop the lift
			motor[Lift]=0;
			//move the lift back down to the limit.
			while(nMotorEncoder[Lift]>LIFT_MAX){
				motor[Lift]=-10;
				LiftState=Running;
			}
			//now stop the motor again.
			motor[Lift]=0;
			LiftState=Stopped;
		}
	}

}
